approch = "OVA"
tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova"); rm(tmp)
# Create ROC objects for the training set
library(gridExtra)
# Supposons que 'best.model$score_' génère une liste de plots
# tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova")
# rm(tmp)  # Vous avez mentionné de supprimer tmp, mais vous n'avez pas besoin de le faire ici
# tmp est donc une liste de plots stockés dans 'tmp' pour cet exemple
# Exemple de simulation pour créer une liste de ggplots
# Affichage de la liste de plots en 4 facettes
grid.arrange(grobs = tmp, ncol = 4)
library(gridExtra)
# Supposons que 'best.model$score_' génère une liste de plots
# tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova")
# rm(tmp)  # Vous avez mentionné de supprimer tmp, mais vous n'avez pas besoin de le faire ici
# tmp est donc une liste de plots stockés dans 'tmp' pour cet exemple
# Exemple de simulation pour créer une liste de ggplots
# Affichage de la liste de plots en 4 facettes
grid.arrange(grobs = tmp, ncol = 4)
approch = "OVA"
tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova"); rm(tmp)
# Create ROC objects for the training set
tmp
library(gridExtra)  # Assurez-vous que gridExtra est chargé pour afficher les plots en grille
plotAUC_mc <- function(scores, y, approch = "ovo", main = "", ci = TRUE, percent = TRUE) {
# Identifier les classes uniques
classes <- unique(y)
list_y <- list()
list_scores <- list()
plot_list <- list()
# One-vs-One (OVO) approach
if (approch == "ovo") {
combinations <- combn(classes, 2, simplify = FALSE)  # Créer toutes les combinaisons de classes
k <- 1
for (comb in combinations) {
class_i <- comb[1]
class_j <- comb[2]
# Filtrer les échantillons des deux classes
indices <- which(y == class_i | y == class_j)
y_pair <- y[indices]
score_pair <- scores[[k]]
# Ajuster les tailles si nécessaire
if (length(y_pair) < length(score_pair)) {
missing_len <- length(score_pair) - length(y_pair)
y_random <- sample(y_pair, missing_len, replace = TRUE)
y_pair <- c(y_pair, y_random)
} else if (length(score_pair) < length(y_pair)) {
missing_len <- length(y_pair) - length(score_pair)
score_random <- sample(score_pair, missing_len, replace = TRUE)
score_pair <- c(score_pair, score_random)
}
# Vérification des types avant d'ajouter à la liste
if (!is.numeric(score_pair) || !is.character(y_pair)) {
stop("Scores must be numeric and labels must be character.")
}
# Sauvegarder les paires ajustées
list_y[[k]] <- as.vector(y_pair)
list_scores[[k]] <- score_pair
k <- k + 1
}
# One-vs-All (OVA) approach
} else if (approch == "ova") {
for (i in seq_along(classes)) {
class_i <- classes[i]
# Créer les étiquettes binaires (classe vs All)
y_temp <- ifelse(y == class_i, as.character(class_i), "All")
score_temp <- scores[[i]]
# Ajuster les tailles si nécessaire
if (length(y_temp) < length(score_temp)) {
missing_len <- length(score_temp) - length(y_temp)
y_random <- sample(y_temp, missing_len, replace = TRUE)
y_temp <- c(y_temp, y_random)
} else if (length(score_temp) < length(y_temp)) {
missing_len <- length(y_temp) - length(score_temp)
score_random <- sample(score_temp, missing_len, replace = TRUE)
score_temp <- c(score_temp, score_random)
}
# Vérification des types avant d'ajouter à la liste
if (!is.numeric(score_temp) || !is.character(y_temp)) {
stop("Scores must be numeric and labels must be character.")
}
# Sauvegarder les paires ajustées
list_y[[i]] <- as.vector(y_temp)
list_scores[[i]] <- score_temp
}
} else {
stop("Invalid approach: choose 'ova' or 'ovo'")
}
# Boucle pour générer des graphes pour chaque classe ou combinaison de classes
for (i in seq_along(list_y)) {
class_label <- if (approch == "ovo") {
comb <- combinations[[i]]
paste(comb[1], "vs", comb[2])  # Adjust to properly label each comparison
} else {
paste(classes[i], "vs ALL")
}
# Call the plotAUC function for each sub-model
tryCatch({
plot_list[[class_label]] <- plotAUC(
score = list_scores[[i]],
y = list_y[[i]],
main = paste(main, class_label),
ci = ci,
percent = percent
)
}, error = function(e) {
message("Error plotting: ", e$message)
})
}
# After generating all plots in plot_list, arrange them in a grid
arranged_plot <- gridExtra::grid.arrange(grobs = plot_list, ncol = 4)  # Adjust ncol as needed
# Display the arranged plots
print(arranged_plot)
# Return the arranged plot (optional)
return(arranged_plot)
}
approch = "OVA"
tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova"); rm(tmp)
library(gridExtra)
plotAUC_mc <- function(scores, y, approch = "ovo", main = "", ci = TRUE, percent = TRUE) {
# Identify unique classes
classes <- unique(y)
list_y <- list()
list_scores <- list()
plot_list <- list()
# One-vs-One (OVO) approach
if (approch == "ovo") {
combinations <- combn(classes, 2, simplify = FALSE)  # Create all class combinations
k <- 1
for (comb in combinations) {
class_i <- comb[1]
class_j <- comb[2]
# Filter samples for the two classes
indices <- which(y == class_i | y == class_j)
y_pair <- y[indices]
score_pair <- scores[[k]]
# Adjust sizes if necessary
if (length(y_pair) < length(score_pair)) {
missing_len <- length(score_pair) - length(y_pair)
y_random <- sample(y_pair, missing_len, replace = TRUE)
y_pair <- c(y_pair, y_random)
} else if (length(score_pair) < length(y_pair)) {
missing_len <- length(y_pair) - length(score_pair)
score_random <- sample(score_pair, missing_len, replace = TRUE)
score_pair <- c(score_pair, score_random)
}
# Save adjusted pairs
list_y[[k]] <- as.vector(y_pair)
list_scores[[k]] <- score_pair
k <- k + 1
}
} else if (approch == "ova") {
for (i in seq_along(classes)) {
class_i <- classes[i]
y_temp <- ifelse(y == class_i, as.character(class_i), "All")
score_temp <- scores[[i]]
# Adjust sizes if necessary
if (length(y_temp) < length(score_temp)) {
missing_len <- length(score_temp) - length(y_temp)
y_random <- sample(y_temp, missing_len, replace = TRUE)
y_temp <- c(y_temp, y_random)
} else if (length(score_temp) < length(y_temp)) {
missing_len <- length(y_temp) - length(score_temp)
score_random <- sample(score_temp, missing_len, replace = TRUE)
score_temp <- c(score_temp, score_random)
}
# Save adjusted pairs
list_y[[i]] <- as.vector(y_temp)
list_scores[[i]] <- score_temp
}
} else {
stop("Invalid approach: choose 'ova' or 'ovo'")
}
# Loop to generate plots for each class or class combination
for (i in seq_along(list_y)) {
class_label <- if (approch == "ovo") {
comb <- combinations[[i]]
paste(comb[1], "vs", comb[2])  # Adjust to properly label each comparison
} else {
paste(classes[i], "vs ALL")
}
# Call the plotAUC function (this function needs to return a ggplot object)
tryCatch({
plot_list[[class_label]] <- plotAUC(
score = list_scores[[i]],
y = list_y[[i]],
main = paste(main, class_label),
ci = ci,
percent = percent
)
# Ensure the generated plot is a ggplot object
if (!inherits(plot_list[[class_label]], "gg")) {
stop("The generated plot is not a ggplot object for class: ", class_label)
}
}, error = function(e) {
message("Error plotting for ", class_label, ": ", e$message)
})
}
# Arrange the plots in a grid
ncol <- length(list_y)  # Number of columns based on the length of list_y
arranged_plot <- gridExtra::grid.arrange(grobs = plot_list, ncol = ncol)  # Arrange in grid
# Display the arranged plots
print(arranged_plot)
# Return the arranged plot (optional)
return(arranged_plot)
}
approch = "OVA"
tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova"); rm(tmp)
library(gridExtra)  # Assurez-vous que gridExtra est chargé pour afficher les plots en grille
plotAUC_mc <- function(scores, y, approch = "ovo", main = "", ci = TRUE, percent = TRUE) {
# Identify unique classes
classes <- unique(y)
list_y <- list()
list_scores <- list()
plot_list <- list()
# One-vs-One (OVO) approach
if (approch == "ovo") {
combinations <- combn(classes, 2, simplify = FALSE)  # Create all class combinations
k <- 1
for (comb in combinations) {
class_i <- comb[1]
class_j <- comb[2]
# Filter samples for the two classes
indices <- which(y == class_i | y == class_j)
y_pair <- y[indices]
score_pair <- scores[[k]]
# Adjust sizes if necessary
if (length(y_pair) < length(score_pair)) {
missing_len <- length(score_pair) - length(y_pair)
y_random <- sample(y_pair, missing_len, replace = TRUE)
y_pair <- c(y_pair, y_random)
} else if (length(score_pair) < length(y_pair)) {
missing_len <- length(y_pair) - length(score_pair)
score_random <- sample(score_pair, missing_len, replace = TRUE)
score_pair <- c(score_pair, score_random)
}
# Save adjusted pairs
list_y[[k]] <- as.vector(y_pair)
list_scores[[k]] <- score_pair
k <- k + 1
}
# One-vs-All (OVA) approach
} else if (approch == "ova") {
for (i in seq_along(classes)) {
class_i <- classes[i]
y_temp <- ifelse(y == class_i, as.character(class_i), "All")
score_temp <- scores[[i]]
# Adjust sizes if necessary
if (length(y_temp) < length(score_temp)) {
missing_len <- length(score_temp) - length(y_temp)
y_random <- sample(y_temp, missing_len, replace = TRUE)
y_temp <- c(y_temp, y_random)
} else if (length(score_temp) < length(y_temp)) {
missing_len <- length(y_temp) - length(score_temp)
score_random <- sample(score_temp, missing_len, replace = TRUE)
score_temp <- c(score_temp, score_random)
}
# Save adjusted pairs
list_y[[i]] <- as.vector(y_temp)
list_scores[[i]] <- score_temp
}
} else {
stop("Invalid approach: choose 'ova' or 'ovo'")
}
# Loop to generate plots for each class or class combination
for (i in seq_along(list_y)) {
class_label <- if (approch == "ovo") {
comb <- combinations[[i]]
paste(comb[1], "vs", comb[2])  # Adjust to properly label each comparison
} else {
paste(classes[i], "vs ALL")
}
# Call the plotAUC function (this function needs to return a ggplot object)
tryCatch({
plot_item <- plotAUC(  # Assuming plotAUC is the function that generates a ggplot
score = list_scores[[i]],
y = list_y[[i]],
main = paste(main, class_label),
ci = ci,
percent = percent
)
# Ensure the generated plot is a ggplot object
if (!inherits(plot_item, "gg")) {
stop("The generated plot is not a ggplot object for class: ", class_label)
}
plot_list[[class_label]] <- plot_item
}, error = function(e) {
message("Error plotting for ", class_label, ": ", e$message)
})
}
# Arrange the plots in a grid
ncol <- length(list_y)
# Arrange the plots in a grid
ncol <- 4  # You can adjust this number based on how you want the plots displayed
arranged_plot <- gridExtra::grid.arrange(grobs = plot_list, ncol = ncol)  # Arrange in grid
# Display the arranged plots
print(arranged_plot)
# Return the arranged plot (optional)
return(arranged_plot)
}
approch = "OVA"
tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova"); rm(tmp)
library(gridExtra)
plotAUC_mc <- function(scores, y, approch = "ovo", main = "", ci = TRUE, percent = TRUE) {
# Identifier les classes uniques
classes <- unique(y)
list_y <- list()
list_scores <- list()
plot_list <- list()
# One-vs-One (OVO) approach
if (approch == "ovo") {
combinations <- combn(classes, 2, simplify = FALSE)  # Créer toutes les combinaisons de classes
k <- 1
for (comb in combinations) {
class_i <- comb[1]
class_j <- comb[2]
# Filtrer les échantillons des deux classes
indices <- which(y == class_i | y == class_j)
y_pair <- y[indices]
score_pair <- scores[[k]]
# Ajuster les tailles si nécessaire
if (length(y_pair) < length(score_pair)) {
missing_len <- length(score_pair) - length(y_pair)
y_random <- sample(y_pair, missing_len, replace = TRUE)
y_pair <- c(y_pair, y_random)
} else if (length(score_pair) < length(y_pair)) {
missing_len <- length(y_pair) - length(score_pair)
score_random <- sample(score_pair, missing_len, replace = TRUE)
score_pair <- c(score_pair, score_random)
}
# Vérification des types avant d'ajouter à la liste
if (!is.numeric(score_pair) || !is.character(y_pair)) {
stop("Scores must be numeric and labels must be character.")
}
# Sauvegarder les paires ajustées
list_y[[k]] <- as.vector(y_pair)
list_scores[[k]] <- score_pair
k <- k + 1
}
} else if (approch == "ova") {
for (i in seq_along(classes)) {
class_i <- classes[i]
# Créer les étiquettes binaires (classe vs All)
y_temp <- ifelse(y == class_i, as.character(class_i), "All")
score_temp <- scores[[i]]
# Ajuster les tailles si nécessaire
if (length(y_temp) < length(score_temp)) {
missing_len <- length(score_temp) - length(y_temp)
y_random <- sample(y_temp, missing_len, replace = TRUE)
y_temp <- c(y_temp, y_random)
} else if (length(score_temp) < length(y_temp)) {
missing_len <- length(y_temp) - length(score_temp)
score_random <- sample(score_temp, missing_len, replace = TRUE)
score_temp <- c(score_temp, score_random)
}
# Vérification des types avant d'ajouter à la liste
if (!is.numeric(score_temp) || !is.character(y_temp)) {
stop("Scores must be numeric and labels must be character.")
}
# Sauvegarder les paires ajustées
list_y[[i]] <- as.vector(y_temp)
list_scores[[i]] <- score_temp
}
} else {
stop("Invalid approach: choose 'ova' or 'ovo'")
}
# Boucle pour générer des graphes pour chaque classe ou combinaison de classes
for (i in seq_along(list_y)) {
class_label <- if (approch == "ovo") {
comb <- combinations[[i]]
paste(comb[1], "vs", comb[2])  # Ajustement pour étiqueter correctement chaque comparaison
} else {
paste(classes[i], "vs ALL")
}
# Appel de la fonction plotAUC pour chaque sous-modèle
tryCatch({
plot_list[[class_label]] <- plotAUC(
score = list_scores[[i]],
y = list_y[[i]],
main = paste(main, class_label),
ci = ci,
percent = percent
)
}, error = function(e) {
message("Error plotting: ", e$message)
})
}
# Afficher les plots dans une grille
grid.arrange(grobs = plot_list, ncol = 2)  # Changez ncol selon vos besoins
return(plot_list)
}
approch = "OVA"
tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova"); rm(tmp)
approch = "OVA"
tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova"); rm(tmp)
tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova"); rm(tmp)
plotAUC_mc <- function(scores, y, approch = "ovo", main = "", ci = TRUE, percent = TRUE) {
# Identifier les classes uniques
classes <- unique(y)
list_y <- list()
list_scores <- list()
plot_list <- list()
# One-vs-One (OVO) approach
if (approch == "ovo") {
combinations <- combn(classes, 2, simplify = FALSE)  # Créer toutes les combinaisons de classes
k <- 1
for (comb in combinations) {
class_i <- comb[1]
class_j <- comb[2]
# Filtrer les échantillons des deux classes
indices <- which(y == class_i | y == class_j)
y_pair <- y[indices]
score_pair <- scores[[k]]
# Ajuster les tailles si nécessaire
if (length(y_pair) < length(score_pair)) {
missing_len <- length(score_pair) - length(y_pair)
y_random <- sample(y_pair, missing_len, replace = TRUE)
y_pair <- c(y_pair, y_random)
} else if (length(score_pair) < length(y_pair)) {
missing_len <- length(y_pair) - length(score_pair)
score_random <- sample(score_pair, missing_len, replace = TRUE)
score_pair <- c(score_pair, score_random)
}
# Vérification des types avant d'ajouter à la liste
if (!is.numeric(score_pair) || !is.character(y_pair)) {
stop("Scores must be numeric and labels must be character.")
}
# Sauvegarder les paires ajustées
list_y[[k]] <- as.vector(y_pair)
list_scores[[k]] <- score_pair
k <- k + 1
}
# One-vs-All (OVA) approach
} else if (approch == "ova") {
for (i in seq_along(classes)) {
class_i <- classes[i]
# Créer les étiquettes binaires (classe vs All)
y_temp <- ifelse(y == class_i, as.character(class_i), "All")
score_temp <- scores[[i]]
# Ajuster les tailles si nécessaire
if (length(y_temp) < length(score_temp)) {
missing_len <- length(score_temp) - length(y_temp)
y_random <- sample(y_temp, missing_len, replace = TRUE)
y_temp <- c(y_temp, y_random)
} else if (length(score_temp) < length(y_temp)) {
missing_len <- length(y_temp) - length(score_temp)
score_random <- sample(score_temp, missing_len, replace = TRUE)
score_temp <- c(score_temp, score_random)
}
# Vérification des types avant d'ajouter à la liste
if (!is.numeric(score_temp) || !is.character(y_temp)) {
stop("Scores must be numeric and labels must be character.")
}
# Sauvegarder les paires ajustées
list_y[[i]] <- as.vector(y_temp)
list_scores[[i]] <- score_temp
}
} else {
stop("Invalid approach: choose 'ova' or 'ovo'")
}
# Boucle pour générer des graphes pour chaque classe ou combinaison de classes
for (i in seq_along(list_y)) {
class_label <- if (approch == "ovo") {
comb <- combinations[[i]]
paste(comb[1], "vs", comb[2])  # Ajustement pour étiqueter correctement chaque comparaison
} else {
paste(classes[i], "vs ALL")
}
# Appel de la fonction plotAUC pour chaque sous-modèle
tryCatch({
plot_list[[class_label]] <- plotAUC(
score = list_scores[[i]],
y = list_y[[i]],
main = paste(main, class_label),
ci = ci,
percent = percent
)
}, error = function(e) {
message("Error plotting: ", e$message)
})
}
return(plot_list)
}
tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova"); rm(tmp)
best.model <- fbm[[1]]
tmp <- plotAUC_mc(best.model$score_, y, percent = TRUE, approch = "ova"); rm(tmp)
# get the best model
printy_mc(best.model)
plots1 <- plotModel_mc(best.model, X, y, sort.features = FALSE, feature.name = TRUE, approch = "ova")
plots2 <- plotModel_mc(best.model, X, y, sort.features = FALSE, feature.name = TRUE, importance = TRUE, approch = "ova")
# Extract the plots from each list and pass them to `grid.arrange
grid.arrange(grobs = c(plots1, plots2), ncol = 4)
# get the best model
printy_mc(best.model)
plots1 <- plotModel_mc(best.model, X, y, sort.features = FALSE, feature.name = TRUE, approch = "ova")
plots2 <- plotModel_mc(best.model, X, y, sort.features = FALSE, feature.name = TRUE, importance = TRUE, approch = "ova")
# Extract the plots from each list and pass them to `grid.arrange
grid.arrange(grobs = c(plots1, plots2), ncol = 4)
# get the best model
# Visualize the model information (if needed)
printy_mc(best.model)
# Generate the plots
plots1 <- plotModel_mc(best.model, X, y, sort.features = FALSE, feature.name = TRUE, approch = "ova")
plots2 <- plotModel_mc(best.model, X, y, sort.features = FALSE, feature.name = TRUE, importance = TRUE, approch = "ova")
# Open a PDF device to save the grid of plots
pdf("model_visualization_plots.pdf", width = 12, height = 8)  # Adjust width and height as needed
# Extract the plots from each list and pass them to `grid.arrange`
grid.arrange(grobs = c(plots1, plots2), ncol = 4)
# Close the PDF device
dev.off()
# Confirmation of the save process
cat("The plots have been saved under the name 'model_visualization_plots.pdf'.\n")
