"Terbeam constrained" = 15,
"Terga1 constrained" = 8,
"SOTA" = 19
)
# Appliquer un retour à la ligne dans les noms des méthodes uniquement pour le groupe Predomics
df_summary <- df_summary %>%
mutate(Methods = ifelse(Group == "Predomics" & nchar(Methods) > 20,
str_wrap(Methods, width = 20),
Methods)) %>%
# Forcer le retour à la ligne avant "unconstrained" et "constrained"
mutate(Methods = ifelse(Group == "Predomics",
str_replace_all(Methods,
c("unconstrained" = "\nunconstrained",
"constrained" = "\nconstrained")),
Methods))
# Création du graphique dans un PDF paysage
pdf("accuracy_generalization_plot.pdf", width = 14, height = 9, paper = "special")
ggplot(df_summary, aes(x = Methods, y = mean_value, color = Subgroup, shape = Subgroup)) +
geom_point(position = position_dodge(width = 0.5), size = 4) +
geom_errorbar(aes(ymin = mean_value - sd_value, ymax = mean_value + sd_value),
position = position_dodge(width = 0.5), width = 0.2) +
# Ajouter les étoiles là où c'est significatif, en les positionnant juste au-dessus des barres d'erreur
geom_text(aes(y = mean_value + sd_value + 0.02, label = ifelse(!is.na(is_significant), "*", "")),
vjust = -1,  # Ajuste l'étoile légèrement au-dessus de la barre
color = "black", size = 5) +
facet_grid(Dataset ~ Group, scales = "free") +
ylab("accuracy (CV generalization)") +
xlab("Methods") +
theme_bw() +
scale_colour_manual(values = custom_colors) +
scale_shape_manual(values = custom_shapes) +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
legend.position = "bottom") +
coord_cartesian(ylim = c(0, 1))  # Fixer les limites de l'axe Y de 0 à 1
dev.off()
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
# Fusionner les quatre dataframes en ajoutant une colonne pour différencier les datasets
analysis_table_no_balance_1 <- analysis_table_final_complet_no_balance_Metacardis %>%
mutate(Dataset = "Metacardis Enterotype\nno balanced")
analysis_table_balance_2 <- analysis_table_final_complet_balance_Metacardis %>%
mutate(Dataset = "Metacardis Enterotype\nbalanced")
analysis_table_no_balance_3 <- analysis_table_final_complet_no_balance_CRC %>%
mutate(Dataset = "Study on CRC\nno balanced")
analysis_table_no_balance_4 <- analysis_table_final_complet_no_balance_TD2 %>%
mutate(Dataset = "Study on T2D\nno balanced")
# Combiner les quatre tables
df_combined <- bind_rows(
analysis_table_no_balance_1,
analysis_table_balance_2,
analysis_table_no_balance_3,
analysis_table_no_balance_4
)
# Imputation des valeurs manquantes pour les colonnes numériques
df_combined <- df_combined %>%
mutate(across(where(is.numeric), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))
# Renommer "Features" en "k"
df_combined <- df_combined %>% rename(k = Features)
# Convertir en format long
df_long <- df_combined %>%
pivot_longer(
cols = c("Accuracy.empirique", "Accuracy.generalization"),
names_to = c("Metric", "Partition"),
names_sep = "\\.",
values_to = "Value"
) %>%
mutate(
Partition = recode(Partition, 'empirique' = 'train', 'generalization' = 'test'),
Partition = factor(Partition, levels = c("train", "test")),
Value = as.numeric(Value),
Group = case_when(
str_starts(Methods, "terbeam") ~ "Predomics",
str_starts(Methods, "_terbeam") ~ "Predomics",
str_starts(Methods, "terga1") ~ "Predomics",
str_starts(Methods, "_terga1") ~ "Predomics",
TRUE ~ "SOTA"
),
Subgroup = case_when(
str_starts(Methods, "terbeam") ~ "Terbeam unconstrained",
str_starts(Methods, "_terbeam") ~ "Terbeam constrained",
str_starts(Methods, "terga1") ~ "Terga1 unconstrained",
str_starts(Methods, "_terga1") ~ "Terga1 constrained",
TRUE ~ "SOTA"
)
)
# Filtrer pour ne garder que la partition "test" et la métrique "Accuracy"
df_accuracy <- df_long %>%
filter(Metric == "Accuracy" & Partition == "test")
# Résumé statistique
df_summary <- df_accuracy %>%
group_by(Methods, Partition, Metric, k, Subgroup, Group, Dataset) %>%
summarize(
mean_value = mean(Value, na.rm = TRUE),
sd_value = sd(Value, na.rm = TRUE),
.groups = "drop"
)
# Nettoyage des noms de méthodes
df_summary <- df_summary %>%
mutate(Methods = str_remove_all(Methods, "^(terbeam_|_terbeam_|terga1_|_terga1_)|(_no_balance|_balance)$")) %>%
group_by(Methods, Partition, Metric, k, Subgroup, Group, Dataset) %>%
summarize(
mean_value = mean(mean_value, na.rm = TRUE),
sd_value = mean(sd_value, na.rm = TRUE),
.groups = "drop"
) %>%
group_by(Dataset, Group) %>%
mutate(max_accuracy = max(mean_value, na.rm = TRUE)) %>%
ungroup() %>%
mutate(is_max_accuracy = ifelse(mean_value == max_accuracy, TRUE, FALSE))
# Ajouter une colonne pour la significativité avec une étoile
df_summary <- df_summary %>%
mutate(is_significant = ifelse(mean_value > 0.6, "*", NA))  # Exemple avec un seuil de 0.8
# Palette et formes personnalisées
custom_colors <- c(
"Predomics" = "blue",
"SOTA" = "black",
"Terbeam unconstrained" = "darkgreen",
"Terga1 unconstrained" = "darkblue",
"Terbeam constrained" = "lightgreen",
"Terga1 constrained" = "lightblue",
"SOTA" = "black"
)
custom_shapes <- c(
"Terbeam unconstrained" = 17,
"Terga1 unconstrained" = 18,
"Terbeam constrained" = 15,
"Terga1 constrained" = 8,
"SOTA" = 19
)
# Appliquer un retour à la ligne dans les noms des méthodes uniquement pour le groupe Predomics
df_summary <- df_summary %>%
mutate(Methods = ifelse(Group == "Predomics" & nchar(Methods) > 20,
str_wrap(Methods, width = 20),
Methods)) %>%
# Forcer le retour à la ligne avant "unconstrained" et "constrained"
mutate(Methods = ifelse(Group == "Predomics",
str_replace_all(Methods,
c("unconstrained" = "\nunconstrained",
"constrained" = "\nconstrained")),
Methods))
# Création du graphique dans un PDF paysage
pdf("accuracy_generalization_plot.pdf", width = 14, height = 9, paper = "special")
ggplot(df_summary, aes(x = Methods, y = mean_value, color = Subgroup, shape = Subgroup)) +
geom_point(position = position_dodge(width = 0.5), size = 4) +
geom_errorbar(aes(ymin = mean_value - sd_value, ymax = mean_value + sd_value),
position = position_dodge(width = 0.5), width = 0.2) +
# Ajouter les étoiles là où c'est significatif, en les positionnant juste au-dessus des barres d'erreur
geom_text(aes(y = mean_value + sd_value + 0.02, label = ifelse(!is.na(is_significant), "*", "")),
vjust = -1,  # Ajuste l'étoile légèrement au-dessus de la barre
color = "black", size = 5) +
facet_grid(Dataset ~ Group, scales = "free") +
ylab("accuracy (CV generalization)") +
xlab("Methods") +
theme_bw() +
scale_colour_manual(values = custom_colors) +
scale_shape_manual(values = custom_shapes) +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
legend.position = "bottom") +
coord_cartesian(ylim = c(0, 1))  # Fixer les limites de l'axe Y de 0 à 1
dev.off()
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
# Fusionner les quatre dataframes en ajoutant une colonne pour différencier les datasets
analysis_table_no_balance_1 <- analysis_table_final_complet_no_balance_Metacardis %>%
mutate(Dataset = "Metacardis Enterotype\nno balanced")
analysis_table_balance_2 <- analysis_table_final_complet_balance_Metacardis %>%
mutate(Dataset = "Metacardis Enterotype\nbalanced")
analysis_table_no_balance_3 <- analysis_table_final_complet_no_balance_CRC %>%
mutate(Dataset = "Study on CRC\nno balanced")
analysis_table_no_balance_4 <- analysis_table_final_complet_no_balance_TD2 %>%
mutate(Dataset = "Study on T2D\nno balanced")
# Combiner les quatre tables
df_combined <- bind_rows(
analysis_table_no_balance_1,
analysis_table_balance_2,
analysis_table_no_balance_3,
analysis_table_no_balance_4
)
# Imputation des valeurs manquantes pour les colonnes numériques
df_combined <- df_combined %>%
mutate(across(where(is.numeric), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))
# Renommer "Features" en "k"
df_combined <- df_combined %>% rename(k = Features)
# Convertir en format long
df_long <- df_combined %>%
pivot_longer(
cols = c("Accuracy.empirique", "Accuracy.generalization"),
names_to = c("Metric", "Partition"),
names_sep = "\\.",
values_to = "Value"
) %>%
mutate(
Partition = recode(Partition, 'empirique' = 'train', 'generalization' = 'test'),
Partition = factor(Partition, levels = c("train", "test")),
Value = as.numeric(Value),
Group = case_when(
str_starts(Methods, "terbeam") ~ "Predomics",
str_starts(Methods, "_terbeam") ~ "Predomics",
str_starts(Methods, "terga1") ~ "Predomics",
str_starts(Methods, "_terga1") ~ "Predomics",
TRUE ~ "SOTA"
),
Subgroup = case_when(
str_starts(Methods, "terbeam") ~ "Terbeam unconstrained",
str_starts(Methods, "_terbeam") ~ "Terbeam constrained",
str_starts(Methods, "terga1") ~ "Terga1 unconstrained",
str_starts(Methods, "_terga1") ~ "Terga1 constrained",
TRUE ~ "SOTA"
)
)
# Filtrer pour ne garder que la partition "test" et la métrique "Accuracy"
df_accuracy <- df_long %>%
filter(Metric == "Accuracy" & Partition == "test")
# Résumé statistique
df_summary <- df_accuracy %>%
group_by(Methods, Partition, Metric, k, Subgroup, Group, Dataset) %>%
summarize(
mean_value = mean(Value, na.rm = TRUE),
sd_value = sd(Value, na.rm = TRUE),
.groups = "drop"
)
# Nettoyage des noms de méthodes
df_summary <- df_summary %>%
mutate(Methods = str_remove_all(Methods, "^(terbeam_|_terbeam_|terga1_|_terga1_)|(_no_balance|_balance)$")) %>%
group_by(Methods, Partition, Metric, k, Subgroup, Group, Dataset) %>%
summarize(
mean_value = mean(mean_value, na.rm = TRUE),
sd_value = mean(sd_value, na.rm = TRUE),
.groups = "drop"
) %>%
group_by(Dataset, Group) %>%
mutate(max_accuracy = max(mean_value, na.rm = TRUE)) %>%
ungroup() %>%
mutate(is_max_accuracy = ifelse(mean_value == max_accuracy, TRUE, FALSE))
# Ajouter une colonne pour la significativité avec une étoile
df_summary <- df_summary %>%
mutate(is_significant = ifelse(mean_value > 0.7, "*", NA))  # Seuil de 0.7 pour les étoiles
# Palette et formes personnalisées
custom_colors <- c(
"Predomics" = "blue",
"SOTA" = "black",
"Terbeam unconstrained" = "darkgreen",
"Terga1 unconstrained" = "darkblue",
"Terbeam constrained" = "lightgreen",
"Terga1 constrained" = "lightblue"
)
custom_shapes <- c(
"Terbeam unconstrained" = 17,
"Terga1 unconstrained" = 18,
"Terbeam constrained" = 15,
"Terga1 constrained" = 8,
"SOTA" = 19
)
# Création du graphique dans un PDF paysage
pdf("accuracy_generalization_plot.pdf", width = 14, height = 9, paper = "special")
ggplot(df_summary, aes(x = Methods, y = mean_value, color = Subgroup, shape = Subgroup)) +
geom_point(position = position_dodge(width = 0.5), size = 4) +
geom_errorbar(aes(ymin = mean_value - sd_value, ymax = mean_value + sd_value),
position = position_dodge(width = 0.5), width = 0.2) +
# Ajouter les étoiles où c'est significatif
geom_text(aes(label = is_significant), vjust = 1, color = "black", size = 5) +  # Placer les étoiles à 1 unité au-dessus des barres
facet_grid(Dataset ~ Group, scales = "free") +
ylab("accuracy (CV generalization)") +
xlab("Methods") +
theme_bw() +
scale_colour_manual(values = custom_colors) +
scale_shape_manual(values = custom_shapes) +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
legend.position = "bottom")
dev.off()
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
# Fusionner les quatre dataframes en ajoutant une colonne pour différencier les datasets
analysis_table_no_balance_1 <- analysis_table_final_complet_no_balance_Metacardis %>%
mutate(Dataset = "Metacardis Enterotype\nno balanced")
analysis_table_balance_2 <- analysis_table_final_complet_balance_Metacardis %>%
mutate(Dataset = "Metacardis Enterotype\nbalanced")
analysis_table_no_balance_3 <- analysis_table_final_complet_no_balance_CRC %>%
mutate(Dataset = "Study on CRC\nno balanced")
analysis_table_no_balance_4 <- analysis_table_final_complet_no_balance_TD2 %>%
mutate(Dataset = "Study on T2D\nno balanced")
# Combiner les quatre tables
df_combined <- bind_rows(
analysis_table_no_balance_1,
analysis_table_balance_2,
analysis_table_no_balance_3,
analysis_table_no_balance_4
)
# Imputation des valeurs manquantes pour les colonnes numériques
df_combined <- df_combined %>%
mutate(across(where(is.numeric), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))
# Renommer "Features" en "k"
df_combined <- df_combined %>% rename(k = Features)
# Convertir en format long
df_long <- df_combined %>%
pivot_longer(
cols = c("Accuracy.empirique", "Accuracy.generalization"),
names_to = c("Metric", "Partition"),
names_sep = "\\.",
values_to = "Value"
) %>%
mutate(
Partition = recode(Partition, 'empirique' = 'train', 'generalization' = 'test'),
Partition = factor(Partition, levels = c("train", "test")),
Value = as.numeric(Value),
Group = case_when(
str_starts(Methods, "terbeam") ~ "Predomics",
str_starts(Methods, "_terbeam") ~ "Predomics",
str_starts(Methods, "terga1") ~ "Predomics",
str_starts(Methods, "_terga1") ~ "Predomics",
TRUE ~ "SOTA"
),
Subgroup = case_when(
str_starts(Methods, "terbeam") ~ "Terbeam unconstrained",
str_starts(Methods, "_terbeam") ~ "Terbeam constrained",
str_starts(Methods, "terga1") ~ "Terga1 unconstrained",
str_starts(Methods, "_terga1") ~ "Terga1 constrained",
TRUE ~ "SOTA"
)
)
# Filtrer pour ne garder que la partition "test" et la métrique "Accuracy"
df_accuracy <- df_long %>%
filter(Metric == "Accuracy" & Partition == "test")
# Résumé statistique
df_summary <- df_accuracy %>%
group_by(Methods, Partition, Metric, k, Subgroup, Group, Dataset) %>%
summarize(
mean_value = mean(Value, na.rm = TRUE),
sd_value = sd(Value, na.rm = TRUE),
.groups = "drop"
)
# Nettoyage des noms de méthodes
df_summary <- df_summary %>%
mutate(Methods = str_remove_all(Methods, "^(terbeam_|_terbeam_|terga1_|_terga1_)|(_no_balance|_balance)$")) %>%
group_by(Methods, Partition, Metric, k, Subgroup, Group, Dataset) %>%
summarize(
mean_value = mean(mean_value, na.rm = TRUE),
sd_value = mean(sd_value, na.rm = TRUE),
.groups = "drop"
) %>%
group_by(Dataset, Group) %>%
mutate(max_accuracy = max(mean_value, na.rm = TRUE)) %>%
ungroup() %>%
mutate(is_max_accuracy = ifelse(mean_value == max_accuracy, TRUE, FALSE))
# Ajouter une colonne pour la significativité avec une étoile
df_summary <- df_summary %>%
mutate(is_significant = ifelse(mean_value > 0.7, "*", NA))  # Seuil de 0.7 pour les étoiles
# Palette et formes personnalisées
custom_colors <- c(
"Predomics" = "blue",
"SOTA" = "black",
"Terbeam unconstrained" = "darkgreen",
"Terga1 unconstrained" = "darkblue",
"Terbeam constrained" = "lightgreen",
"Terga1 constrained" = "lightblue"
)
custom_shapes <- c(
"Terbeam unconstrained" = 17,
"Terga1 unconstrained" = 18,
"Terbeam constrained" = 15,
"Terga1 constrained" = 8,
"SOTA" = 19
)
# Création du graphique dans un PDF paysage
pdf("accuracy_generalization_plot.pdf", width = 14, height = 9, paper = "special")
ggplot(df_summary, aes(x = Methods, y = mean_value, color = Subgroup, shape = Subgroup)) +
geom_point(position = position_dodge(width = 0.5), size = 4) +
geom_errorbar(aes(ymin = mean_value - sd_value, ymax = mean_value + sd_value),
position = position_dodge(width = 0.5), width = 0.2) +
# Ajouter les étoiles où c'est significatif
geom_text(aes(label = is_significant), vjust = 1, color = "black", size = 5) +  # Placer les étoiles à 1 unité au-dessus des barres
facet_grid(Dataset ~ Group, scales = "free") +
ylab("accuracy (CV generalization)") +
xlab("Methods") +
theme_bw() +
scale_colour_manual(values = custom_colors) +
scale_shape_manual(values = custom_shapes) +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
legend.position = "bottom")
dev.off()
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
# Fusionner les quatre dataframes en ajoutant une colonne pour différencier les datasets
analysis_table_no_balance_1 <- analysis_table_final_complet_no_balance_Metacardis %>%
mutate(Dataset = "Metacardis Enterotype\nno balanced")
analysis_table_balance_2 <- analysis_table_final_complet_balance_Metacardis %>%
mutate(Dataset = "Metacardis Enterotype\nbalanced")
analysis_table_no_balance_3 <- analysis_table_final_complet_no_balance_CRC %>%
mutate(Dataset = "Study on CRC\nno balanced")
analysis_table_no_balance_4 <- analysis_table_final_complet_no_balance_TD2 %>%
mutate(Dataset = "Study on T2D\nno balanced")
# Combiner les quatre tables
df_combined <- bind_rows(
analysis_table_no_balance_1,
analysis_table_balance_2,
analysis_table_no_balance_3,
analysis_table_no_balance_4
)
# Imputation des valeurs manquantes pour les colonnes numériques
df_combined <- df_combined %>%
mutate(across(where(is.numeric), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))
# Renommer "Features" en "k"
df_combined <- df_combined %>% rename(k = Features)
# Convertir en format long
df_long <- df_combined %>%
pivot_longer(
cols = c("Accuracy.empirique", "Accuracy.generalization"),
names_to = c("Metric", "Partition"),
names_sep = "\\.",
values_to = "Value"
) %>%
mutate(
Partition = recode(Partition, 'empirique' = 'train', 'generalization' = 'test'),
Partition = factor(Partition, levels = c("train", "test")),
Value = as.numeric(Value),
Group = case_when(
str_starts(Methods, "terbeam") ~ "Predomics",
str_starts(Methods, "_terbeam") ~ "Predomics",
str_starts(Methods, "terga1") ~ "Predomics",
str_starts(Methods, "_terga1") ~ "Predomics",
TRUE ~ "SOTA"
),
Subgroup = case_when(
str_starts(Methods, "terbeam") ~ "Terbeam unconstrained",
str_starts(Methods, "_terbeam") ~ "Terbeam constrained",
str_starts(Methods, "terga1") ~ "Terga1 unconstrained",
str_starts(Methods, "_terga1") ~ "Terga1 constrained",
TRUE ~ "SOTA"
)
)
# Filtrer pour ne garder que la partition "test" et la métrique "Accuracy"
df_accuracy <- df_long %>%
filter(Metric == "Accuracy" & Partition == "test")
# Résumé statistique
df_summary <- df_accuracy %>%
group_by(Methods, Partition, Metric, k, Subgroup, Group, Dataset) %>%
summarize(
mean_value = mean(Value, na.rm = TRUE),
sd_value = sd(Value, na.rm = TRUE),
.groups = "drop"
)
# Nettoyage des noms de méthodes
df_summary <- df_summary %>%
mutate(Methods = str_remove_all(Methods, "^(terbeam_|_terbeam_|terga1_|_terga1_)|(_no_balance|_balance)$")) %>%
group_by(Methods, Partition, Metric, k, Subgroup, Group, Dataset) %>%
summarize(
mean_value = mean(mean_value, na.rm = TRUE),
sd_value = mean(sd_value, na.rm = TRUE),
.groups = "drop"
) %>%
group_by(Dataset, Group) %>%
mutate(max_accuracy = max(mean_value, na.rm = TRUE)) %>%
ungroup() %>%
mutate(is_max_accuracy = ifelse(mean_value == max_accuracy, TRUE, FALSE))
# Ajouter une colonne pour la significativité
df_summary <- df_summary %>%
mutate(is_significant = ifelse(mean_value > 0.8, "*", NA))  # Exemple avec un seuil de 0.8
# Palette et formes personnalisées
custom_colors <- c(
"Predomics" = "blue",
"SOTA" = "black",
"Terbeam unconstrained" = "darkgreen",
"Terga1 unconstrained" = "darkblue",
"Terbeam constrained" = "lightgreen",
"Terga1 constrained" = "lightblue",
"SOTA" = "black"
)
custom_shapes <- c(
"Terbeam unconstrained" = 17,
"Terga1 unconstrained" = 18,
"Terbeam constrained" = 15,
"Terga1 constrained" = 8,
"SOTA" = 19
)
# Appliquer un retour à la ligne dans les noms des méthodes uniquement pour le groupe Predomics
df_summary <- df_summary %>%
mutate(Methods = ifelse(Group == "Predomics" & nchar(Methods) > 20,
str_wrap(Methods, width = 20),
Methods)) %>%
# Forcer le retour à la ligne avant "unconstrained" et "constrained"
mutate(Methods = ifelse(Group == "Predomics",
str_replace_all(Methods,
c("unconstrained" = "\nunconstrained",
"constrained" = "\nconstrained")),
Methods))
# Création du graphique dans un PDF paysage
pdf("accuracy_generalization_plot.pdf", width = 14, height = 9, paper = "special")
ggplot(df_summary, aes(x = Methods, y = mean_value, color = Subgroup, shape = Subgroup)) +
geom_point(position = position_dodge(width = 0.5), size = 4) +
geom_errorbar(aes(ymin = mean_value - sd_value, ymax = mean_value + sd_value),
position = position_dodge(width = 0.5), width = 0.2) +
geom_point(data = subset(df_summary, is_max_accuracy == TRUE),
aes(x = Methods, y = mean_value),
shape = 8, color = "red", size = 5) +  # Étoile rouge pour max
geom_text(aes(label = is_significant), vjust = -1, color = "black", size = 5) +  # Ajouter les étoiles
facet_grid(Dataset ~ Group, scales = "free") +
ylab("accuracy (CV generalization)") +
xlab("Methods") +
theme_bw() +
scale_colour_manual(values = custom_colors) +
scale_shape_manual(values = custom_shapes) +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
legend.position = "bottom")
dev.off()
