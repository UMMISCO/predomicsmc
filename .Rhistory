# Filtrer pour conserver uniquement acc, f1s, prc, et rec
alldf <- alldf[alldf$metric %in% c("acc", "f1s", "prc", "rec"), ]
# Visualisation des résultats des deux modèles
ggplot(alldf, aes(x=model, y=value)) +
geom_point(aes(colour=sparsity)) +
facet_grid(.~metric+emp_gen) +
stat_compare_means(method = "wilcox", label = "p.signif") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Charger les bibliothèques nécessaires
library(reshape2)
library(ggplot2)
library(ggpubr)
# Fonction pour transformer les données des modèles
transform_model_data <- function(model_data, model_name) {
testlist <- model_data$crossVal$scores[grep("generalization|empirical", names(model_data$crossVal$scores))]
testlist2 <- list()
for(i in names(testlist)) {
idf <- testlist[[i]]
if(unique(colSums(is.na(idf))) != nrow(idf)) {
idf$sparsity <- rownames(idf)
idf <- melt(idf)
idf$source <- i
testlist2[[i]] <- idf
}
}
testlist2.df <- do.call("rbind", testlist2)
testlist2.df$emp_gen <- gsub("\\..*$", "", testlist2.df$source)
testlist2.df$metric <- gsub("^.*\\.", "", testlist2.df$source)
testlist2.df$model <- model_name
testlist2.df <- testlist2.df[is.finite(testlist2.df$value), ]
testlist2.df <- testlist2.df[testlist2.df$metric %in% c("acc", "prc"), ]
return(testlist2.df)
}
# Charger les données des modèles existants
df1 <- transform_model_data(Unique_maximizationAggregation, "Unique_maximizationAggregation")
df2 <- transform_model_data(Unique_Predomics_aggregation_ova, "Unique_Predomics_aggregation_ova")
# Charger les nouvelles données des autres modèles
df3 <- transform_model_data(Unique_rankingAggregation, "Unique_rankingAggregation")
df4 <- transform_model_data(Unique_weightedAggregation, "Unique_weightedAggregation")
df5 <- transform_model_data(Unique_votingAggregation, "Unique_votingAggregation")
# Combiner toutes les données
alldf <- rbind(df1, df2, df3, df4, df5)
# Visualisation des résultats des modèles
ggplot(alldf, aes(x=model, y=value)) +
geom_point(aes(colour=sparsity)) +
facet_grid(.~metric+emp_gen) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Charger les bibliothèques nécessaires
library(reshape2)
library(ggplot2)
library(ggpubr)
# Fonction pour transformer les données des modèles
transform_model_data <- function(model_data, model_name) {
testlist <- model_data$crossVal$scores[grep("generalization|empirical", names(model_data$crossVal$scores))]
testlist2 <- list()
for(i in names(testlist)) {
idf <- testlist[[i]]
if(unique(colSums(is.na(idf))) != nrow(idf)) {
idf$sparsity <- rownames(idf)
idf <- melt(idf)
idf$source <- i
testlist2[[i]] <- idf
}
}
testlist2.df <- do.call("rbind", testlist2)
testlist2.df$emp_gen <- gsub("\\..*$", "", testlist2.df$source)
testlist2.df$metric <- gsub("^.*\\.", "", testlist2.df$source)
testlist2.df$model <- model_name
testlist2.df <- testlist2.df[is.finite(testlist2.df$value), ]
testlist2.df <- testlist2.df[testlist2.df$metric %in% c("acc", "prc"), ]
return(testlist2.df)
}
# Charger les données des modèles existants
df1 <- transform_model_data(Unique_maximizationAggregation, "Unique_maximizationAggregation")
df2 <- transform_model_data(Unique_Predomics_aggregation_ova, "Unique_Predomics_aggregation_ova")
# Charger les nouvelles données des autres modèles
df3 <- transform_model_data(Unique_rankingAggregation, "Unique_rankingAggregation")
df4 <- transform_model_data(Unique_weightedAggregation, "Unique_weightedAggregation")
df5 <- transform_model_data(Unique_votingAggregation, "Unique_votingAggregation")
# Combiner toutes les données
alldf <- rbind(df1, df2, df3, df4, df5)
# Visualisation des résultats des modèles
ggplot(alldf, aes(x=model, y=value)) +
geom_point(aes(colour=sparsity)) +
facet_grid(.~metric+emp_gen) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Charger les bibliothèques nécessaires
library(reshape2)
library(ggplot2)
library(ggpubr)
# Fonction pour transformer les données des modèles
transform_model_data <- function(model_data, model_name) {
testlist <- model_data$crossVal$scores[grep("generalization|empirical", names(model_data$crossVal$scores))]
testlist2 <- list()
for(i in names(testlist)) {
idf <- testlist[[i]]
if(unique(colSums(is.na(idf))) != nrow(idf)) {
idf$sparsity <- rownames(idf)
idf <- melt(idf)
idf$source <- i
testlist2[[i]] <- idf
}
}
testlist2.df <- do.call("rbind", testlist2)
testlist2.df$emp_gen <- gsub("\\..*$", "", testlist2.df$source)
testlist2.df$metric <- gsub("^.*\\.", "", testlist2.df$source)
testlist2.df$model <- model_name
testlist2.df <- testlist2.df[is.finite(testlist2.df$value), ]
testlist2.df <- testlist2.df[testlist2.df$metric %in% c("acc", "prc"), ]
return(testlist2.df)
}
# Charger les données des modèles existants
df1 <- transform_model_data(Unique_maximizationAggregation, "Unique_maximizationAggregation")
df2 <- transform_model_data(Unique_Predomics_aggregation_ova, "Unique_Predomics_aggregation_ova")
# Charger les nouvelles données des autres modèles
df3 <- transform_model_data(Unique_rankingAggregation, "Unique_rankingAggregation")
df4 <- transform_model_data(Unique_weightedAggregation, "Unique_weightedAggregation")
df5 <- transform_model_data(Unique_votingAggregation, "Unique_votingAggregation")
# Combiner toutes les données
alldf <- rbind(df1, df2, df3, df4, df5)
# Visualisation des résultats des modèles
ggplot(alldf, aes(x=model, y=value)) +
geom_point(aes(colour=sparsity)) +
facet_grid(.~metric+emp_gen) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Charger les bibliothèques nécessaires
library(reshape2)
library(ggplot2)
library(ggpubr)
# Fonction pour transformer les données des modèles
transform_model_data <- function(model_data, model_name) {
testlist <- model_data$crossVal$scores[grep("generalization|empirical", names(model_data$crossVal$scores))]
testlist2 <- list()
for(i in names(testlist)) {
idf <- testlist[[i]]
if(unique(colSums(is.na(idf))) != nrow(idf)) {
idf$sparsity <- rownames(idf)
idf <- melt(idf)
idf$source <- i
testlist2[[i]] <- idf
}
}
testlist2.df <- do.call("rbind", testlist2)
testlist2.df$emp_gen <- gsub("\\..*$", "", testlist2.df$source)
testlist2.df$metric <- gsub("^.*\\.", "", testlist2.df$source)
testlist2.df$model <- model_name
testlist2.df <- testlist2.df[is.finite(testlist2.df$value), ]
testlist2.df <- testlist2.df[testlist2.df$metric %in% c("acc", "prc"), ]
return(testlist2.df)
}
# Charger les données des modèles existants
df1 <- transform_model_data(Unique_maximizationAggregation, "Unique_maximizationAggregation")
df2 <- transform_model_data(Unique_Predomics_aggregation_ova, "Unique_Predomics_aggregation_ova")
# Charger les nouvelles données des autres modèles
df3 <- transform_model_data(Unique_rankingAggregation, "Unique_rankingAggregation")
df4 <- transform_model_data(Unique_weightedAggregation, "Unique_weightedAggregation")
df5 <- transform_model_data(Unique_votingAggregation, "Unique_votingAggregation")
# Combiner toutes les données
alldf <- rbind(df1, df2, df3, df4, df5)
# Visualisation des résultats des modèles
ggplot(alldf, aes(x=model, y=value)) +
geom_point(aes(colour=sparsity)) +
facet_grid(.~metric+emp_gen) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Fonction pour transformer les données des modèles
transform_model_data <- function(model_data, model_name) {
testlist <- model_data$crossVal$scores[grep("generalization|empirical", names(model_data$crossVal$scores))]
testlist2 <- list()
for(i in names(testlist)) {
idf <- testlist[[i]]
if(unique(colSums(is.na(idf))) != nrow(idf)) {
idf$sparsity <- rownames(idf)
idf <- melt(idf)
idf$source <- i
testlist2[[i]] <- idf
}
}
testlist2.df <- do.call("rbind", testlist2)
testlist2.df$emp_gen <- gsub("\\..*$", "", testlist2.df$source)
testlist2.df$metric <- gsub("^.*\\.", "", testlist2.df$source)
testlist2.df$model <- model_name
testlist2.df <- testlist2.df[is.finite(testlist2.df$value), ]
testlist2.df <- testlist2.df[testlist2.df$metric %in% c("f1s", "rec"), ]
return(testlist2.df)
}
# Charger les données des modèles existants
df1 <- transform_model_data(Unique_maximizationAggregation, "Unique_maximizationAggregation")
df2 <- transform_model_data(Unique_Predomics_aggregation_ova, "Unique_Predomics_aggregation_ova")
# Charger les nouvelles données des autres modèles
df3 <- transform_model_data(Unique_rankingAggregation, "Unique_rankingAggregation")
df4 <- transform_model_data(Unique_weightedAggregation, "Unique_weightedAggregation")
df5 <- transform_model_data(Unique_votingAggregation, "Unique_votingAggregation")
# Combiner toutes les données
alldf <- rbind(df1, df2, df3, df4, df5)
# Visualisation des résultats des modèles
ggplot(alldf, aes(x=model, y=value)) +
geom_point(aes(colour=sparsity)) +
facet_grid(.~metric+emp_gen) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
load("Multi_Predomics_aggregation_ova.rda")
load("Multi_maximizationAggregation.rda")
load("Multi_rankingAggregation.rda")
load("Multi_weightedAggregation.rda")
load("Multi_votingAggregation.rda")
library(reshape2)
library(ggplot2)
library(ggpubr)
transform_model_data <- function(model_data, model_name) {
testlist <- model_data$crossVal$scores[grep("generalization|empirical", names(model_data$crossVal$scores))]
testlist2 <- list()
for(i in names(testlist)) {
idf <- testlist[[i]]
if(unique(colSums(is.na(idf))) != nrow(idf)) {
idf$sparsity <- rownames(idf)
idf <- melt(idf)
idf$source <- i
testlist2[[i]] <- idf
}
}
testlist2.df <- do.call("rbind", testlist2)
testlist2.df$emp_gen <- gsub("\\..*$", "", testlist2.df$source)
testlist2.df$metric <- gsub("^.*\\.", "", testlist2.df$source)
testlist2.df$model <- model_name
testlist2.df <- testlist2.df[is.finite(testlist2.df$value), ]
testlist2.df <- testlist2.df[testlist2.df$metric %in% c("acc", "prc"), ]
return(testlist2.df)
}
df1 <- transform_model_data(Unique_maximizationAggregation, "Multi_maximizationAggregation")
df2 <- transform_model_data(Unique_Predomics_aggregation_ova, "Multi_Predomics_aggregation_ova")
df3 <- transform_model_data(Unique_rankingAggregation, "Multi_rankingAggregation")
df4 <- transform_model_data(Unique_weightedAggregation, "Multi_weightedAggregation")
df5 <- transform_model_data(Unique_votingAggregation, "Multi_votingAggregation")
alldf <- rbind(df1, df2, df3, df4, df5)
ggplot(alldf, aes(x=model, y=value)) +
geom_point(aes(colour=sparsity)) +
facet_grid(.~metric+emp_gen) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
transform_model_data <- function(model_data, model_name) {
testlist <- model_data$crossVal$scores[grep("generalization|empirical", names(model_data$crossVal$scores))]
testlist2 <- list()
for(i in names(testlist)) {
idf <- testlist[[i]]
if(unique(colSums(is.na(idf))) != nrow(idf)) {
idf$sparsity <- rownames(idf)
idf <- melt(idf)
idf$source <- i
testlist2[[i]] <- idf
}
}
testlist2.df <- do.call("rbind", testlist2)
testlist2.df$emp_gen <- gsub("\\..*$", "", testlist2.df$source)
testlist2.df$metric <- gsub("^.*\\.", "", testlist2.df$source)
testlist2.df$model <- model_name
testlist2.df <- testlist2.df[is.finite(testlist2.df$value), ]
testlist2.df <- testlist2.df[testlist2.df$metric %in% c("f1s", "rec"), ]
return(testlist2.df)
}
df1 <- transform_model_data(Unique_maximizationAggregation, "Multi_maximizationAggregation")
df2 <- transform_model_data(Unique_Predomics_aggregation_ova, "Multi_Predomics_aggregation_ova")
df3 <- transform_model_data(Unique_rankingAggregation, "Multi_rankingAggregation")
df4 <- transform_model_data(Unique_weightedAggregation, "Multi_weightedAggregation")
df5 <- transform_model_data(Unique_votingAggregation, "Multi_votingAggregation")
alldf <- rbind(df1, df2, df3, df4, df5)
ggplot(alldf, aes(x=model, y=value)) +
geom_point(aes(colour=sparsity)) +
facet_grid(.~metric+emp_gen) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
Multi_weightedAggregation$crossVal$scores$mean.acc
Multi_maximizationAggregation$crossVal$scores$mean.acc
Multi_Predomics_Aggregation_ova$crossVal$scores$mean.acc
Multi_rankingAggregation$crossVal$scores$mean.acc
Multi_votingAggregation$crossVal$scores$mean.acc
class(Multi_maximizationAggregation$crossVal$scores$mean.acc)
df1 = Multi_weightedAggregation$crossVal$scores$mean.acc
df2 = Multi_maximizationAggregation$crossVal$scores$mean.acc
df3 = Multi_Predomics_Aggregation_ova$crossVal$scores$mean.acc
df4 = Multi_rankingAggregation$crossVal$scores$mean.acc
df5 =Multi_votingAggregation$crossVal$scores$mean.acc
# Fonction pour traiter et afficher les dataframes
plot_aggregations <- function(df1, df2, df3, df4, df5) {
# Fusionner les dataframes fournis en arguments
combined_df <- rbind(df1, df2, df3, df4, df5)
# Supprimer les lignes avec NaN
combined_df <- na.omit(combined_df)
# Transformer les données pour ggplot2
combined_df_melted <- melt(combined_df, id.vars = c("k", "model"), variable.name = "type", value.name = "accuracy")
# Visualiser les résultats
ggplot(combined_df_melted, aes(x = k, y = accuracy, color = model)) +
geom_point(size = 3) +
geom_line(aes(group = interaction(model, type))) +
facet_grid(. ~ type) +
theme_minimal() +
labs(title = "Comparaison des performances empiriques et de généralisation",
x = "Valeur de k",
y = "Accuracy",
color = "Modèle") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
# Appeler la fonction avec les dataframes définis
plot_aggregations(Multi_weightedAggregation, Multi_maximizationAggregation, Multi_Predomics_Aggregation_ova, Multi_rankingAggregation, Multi_votingAggregation)
plot_aggregations <- function(df1, df2, df3, df4, df5) {
# Combine the data frames
combined_df <- rbind(df1, df2, df3, df4, df5)
# Remove rows with NA values
combined_df <- na.omit(combined_df)
# Melt the data
combined_df_melted <- reshape2::melt(combined_df, id.vars = c("k", "model"), variable.name = "type", value.name = "accuracy")
# Visualize the results
ggplot(combined_df_melted, aes(x = k, y = accuracy, color = model)) +
geom_point(size = 3) +
geom_line(aes(group = interaction(model, type))) +
facet_grid(. ~ model) +  # facet by model instead of 'type'
theme_minimal() +
labs(title = "Comparaison des performances empiriques et de généralisation",
x = "Valeur de k",
y = "Accuracy",
color = "Modèle") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
# Call the function with the provided data frames
plot_aggregations(Multi_weightedAggregation$crossVal$scores$mean.acc,
Multi_maximizationAggregation$crossVal$scores$mean.acc,
Multi_Predomics_Aggregation_ova$crossVal$scores$mean.acc,
Multi_rankingAggregation$crossVal$scores$mean.acc,
Multi_votingAggregation$crossVal$scores$mean.acc)
plot_aggregations <- function(df1, df2, df3, df4, df5) {
# Combine the data frames
combined_df <- rbind(df1, df2, df3, df4, df5)
# Remove rows with NA values
combined_df <- na.omit(combined_df)
# Check the structure of combined_df to ensure columns k, model, and mean.acc exist
print(str(combined_df))  # Check the structure
# Melt the data
combined_df_melted <- reshape2::melt(combined_df, id.vars = c("k", "model"), variable.name = "type", value.name = "accuracy")
# Visualize the results
ggplot(combined_df_melted, aes(x = k, y = accuracy, color = model)) +
geom_point(size = 3) +
geom_line(aes(group = interaction(model, type))) +
facet_grid(. ~ model) +  # facet by model instead of 'type'
theme_minimal() +
labs(title = "Comparaison des performances empiriques et de généralisation",
x = "Valeur de k",
y = "Accuracy",
color = "Modèle") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
# Call the function with the provided data frames
plot_aggregations(Multi_weightedAggregation$crossVal$scores$mean.acc,
Multi_maximizationAggregation$crossVal$scores$mean.acc,
Multi_Predomics_Aggregation_ova$crossVal$scores$mean.acc,
Multi_rankingAggregation$crossVal$scores$mean.acc,
Multi_votingAggregation$crossVal$scores$mean.acc)
Multi_votingAggregation$crossVal$scores$mean.acc
plot_aggregations <- function(df1, df2, df3, df4, df5) {
# Combine the data frames
combined_df <- data.frame(
model = rep(c("df1", "df2", "df3", "df4", "df5"), each = nrow(df1)),
k = rep(rownames(df1), 5),
empirical = c(df1$empirical, df2$empirical, df3$empirical, df4$empirical, df5$empirical),
generalization = c(df1$generalization, df2$generalization, df3$generalization, df4$generalization, df5$generalization)
)
# Melt the data
combined_df_melted <- reshape2::melt(combined_df, id.vars = c("k", "model"), variable.name = "type", value.name = "accuracy")
# Visualize the results
ggplot(combined_df_melted, aes(x = k, y = accuracy, color = model)) +
geom_point(size = 3) +
geom_line(aes(group = interaction(model, type))) +
facet_grid(. ~ type) +  # facet by type (empirical vs. generalization)
theme_minimal() +
labs(title = "Comparaison des performances empiriques et de généralisation",
x = "Valeur de k",
y = "Accuracy",
color = "Modèle") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
# Assuming Multi_weightedAggregation, Multi_maximizationAggregation, etc., are your data frames
# Access the correct columns (empirical and generalization) from each data frame
plot_aggregations(
Multi_weightedAggregation$crossVal$scores$mean.acc,
Multi_maximizationAggregation$crossVal$scores$mean.acc,
Multi_Predomics_Aggregation_ova$crossVal$scores$mean.acc,
Multi_rankingAggregation$crossVal$scores$mean.acc,
Multi_votingAggregation$crossVal$scores$mean.acc
)
plot_aggregations <- function(df1, df2, df3, df4, df5) {
# Mapping des noms des modèles
model_names <- c("Multi_weightedAggregation", "Multi_maximizationAggregation",
"Multi_Predomics_Aggregation_ova", "Multi_rankingAggregation",
"Multi_votingAggregation")
# Combine the data frames
combined_df <- data.frame(
model = rep(model_names, each = nrow(df1)),
k = rep(rownames(df1), length(model_names)),
empirical = c(df1$empirical, df2$empirical, df3$empirical, df4$empirical, df5$empirical),
generalization = c(df1$generalization, df2$generalization, df3$generalization, df4$generalization, df5$generalization)
)
# Remove rows with NA values
combined_df <- na.omit(combined_df)
# Filter out specific rows (e.g., 'k_1')
combined_df <- combined_df[combined_df$k != "k_1", ]
# Melt the data
combined_df_melted <- reshape2::melt(combined_df, id.vars = c("k", "model"), variable.name = "type", value.name = "accuracy")
# Visualize the results
ggplot(combined_df_melted, aes(x = k, y = accuracy, color = model)) +
geom_point(size = 3) +
geom_line(aes(group = interaction(model, type))) +
facet_grid(. ~ type) +  # facet by type (empirical vs. generalization)
theme_minimal() +
labs(title = "Comparaison des performances empiriques et de généralisation",
x = "Valeur de k",
y = "Accuracy",
color = "Modèle") +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_color_manual(values = setNames(colors, model_names))  # Assign colors to model names
}
# Call the function with the provided data frames
plot_aggregations(
Multi_weightedAggregation$crossVal$scores$mean.acc,
Multi_maximizationAggregation$crossVal$scores$mean.acc,
Multi_Predomics_Aggregation_ova$crossVal$scores$mean.acc,
Multi_rankingAggregation$crossVal$scores$mean.acc,
Multi_votingAggregation$crossVal$scores$mean.acc
)
plot_aggregations <- function(df1, df2, df3, df4, df5) {
# Mapping des noms des modèles
model_names <- c("Multi_weightedAggregation", "Multi_maximizationAggregation",
"Multi_Predomics_Aggregation_ova", "Multi_rankingAggregation",
"Multi_votingAggregation")
# Combine the data frames
combined_df <- data.frame(
model = rep(model_names, each = nrow(df1)),
k = rep(rownames(df1), length(model_names)),
empirical = c(df1$empirical, df2$empirical, df3$empirical, df4$empirical, df5$empirical),
generalization = c(df1$generalization, df2$generalization, df3$generalization, df4$generalization, df5$generalization)
)
# Remove rows with NA values
combined_df <- na.omit(combined_df)
# Filter out specific rows (e.g., 'k_1')
combined_df <- combined_df[combined_df$k != "k_1", ]
# Melt the data
combined_df_melted <- reshape2::melt(combined_df, id.vars = c("k", "model"), variable.name = "type", value.name = "accuracy")
# Visualize the results
ggplot(combined_df_melted, aes(x = k, y = accuracy, color = model)) +
geom_point(size = 3) +
geom_line(aes(group = interaction(model, type))) +
facet_grid(. ~ type) +  # facet by type (empirical vs. generalization)
theme_minimal() +
labs(title = "Comparaison des performances empiriques et de généralisation",
x = "Valeur de k",
y = "Accuracy",
color = "Modèle") +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_color_manual(values = c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00"),
labels = model_names)
}
# Call the function with the provided data frames
plot_aggregations(
Multi_weightedAggregation$crossVal$scores$mean.acc,
Multi_maximizationAggregation$crossVal$scores$mean.acc,
Multi_Predomics_Aggregation_ova$crossVal$scores$mean.acc,
Multi_rankingAggregation$crossVal$scores$mean.acc,
Multi_votingAggregation$crossVal$scores$mean.acc
)
plot_aggregations <- function(df1, df2, df3, df4, df5) {
# Mapping des noms des modèles
model_names <- c("Multi_weightedAggregation", "Multi_maximizationAggregation",
"Multi_Predomics_Aggregation_ova", "Multi_rankingAggregation",
"Multi_votingAggregation")
# Combine the data frames
combined_df <- data.frame(
model = rep(model_names, each = nrow(df1)),
k = rep(rownames(df1), length(model_names)),
empirical = c(df1$empirical, df2$empirical, df3$empirical, df4$empirical, df5$empirical),
generalization = c(df1$generalization, df2$generalization, df3$generalization, df4$generalization, df5$generalization)
)
# Remove rows with NA values
combined_df <- na.omit(combined_df)
# Filter out specific rows (e.g., 'k_1')
combined_df <- combined_df[combined_df$k != "k_1", ]
# Melt the data
combined_df_melted <- reshape2::melt(combined_df, id.vars = c("k", "model"), variable.name = "type", value.name = "accuracy")
# Visualize the results
ggplot(combined_df_melted, aes(x = k, y = accuracy, color = model)) +
geom_point(size = 3) +
geom_line(aes(group = interaction(model, type))) +
facet_grid(. ~ type) +  # facet by type (empirical vs. generalization)
theme_minimal() +
labs(title = "Comparaison des performances empiriques et de généralisation",
x = "Valeur de k",
y = "Accuracy",
color = "Modèle") +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_color_manual(values = c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00"),
labels = model_names)
}
# Call the function with the provided data frames
plot_aggregations(
Multi_weightedAggregation$crossVal$scores$mean.acc,
Multi_maximizationAggregation$crossVal$scores$mean.acc,
Multi_Predomics_Aggregation_ova$crossVal$scores$mean.acc,
Multi_rankingAggregation$crossVal$scores$mean.acc,
Multi_votingAggregation$crossVal$scores$mean.acc
)
Multi_votingAggregation$crossVal$scores$mean.acc
Multi_weightedAggregation$crossVal$scores$mean.acc
Multi_Predomics_Aggregation_ova$crossVal$scores$mean.acc,
Multi_votingAggregation$crossVal$scores$mean.acc
Multi_weightedAggregation$crossVal$scores$mean.acc
Multi_Predomics_Aggregation_ova$crossVal$scores$mean.acc
Multi_maximizationAggregation$crossVal$scores$mean.acc
Multi_rankingAggregation$crossVal$scores$mean.acc
Unique_rankingAggregation$classifier$models$k_2$k_2$names_
